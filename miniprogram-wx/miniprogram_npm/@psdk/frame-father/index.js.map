{"version":3,"sources":["index.js","device/adapter/index.js","device/adapter/connected_device.js","device/adapter/types.js","father/index.js","father/args/index.js","father/args/arg.js","father/types/index.js","father/types/psdk_const.js","toolkit/index.js","toolkit/byte.js","toolkit/pvariable.js","toolkit/pcollection.js","toolkit/pimage.js","father/types/hex_output.js","father/types/write.js","father/types/lifecycle.js","father/args/common/easy.js","father/command/index.js","father/command/print/command.js","father/command/print/command_clause.js","father/command/print/commander.js","father/command/single/appendat.js","father/command/single/binary_command.js","father/command/single/single_command.js","father/args/common/raw.js","father/PSDK.js","father/device/write_operation.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,ACHA,AJYA;AELA,ADGA,AENA,AENA,ADGA,AJYA;AELA,ADGA,AENA,AENA,ADGA,AJYA;AELA,ADGA,AENA,AENA,ADGA,AJYA;AELA,ADGA,AENA,AGTA,ADGA,ADGA,AJYA;AELA,ADGA,AENA,AGTA,ADGA,ADGA,AJYA;AELA,ADGA,AENA,AGTA,ADGA,ADGA;AFOA,ADGA,AENA,AGTA,ADGA,ADGA,AGTA;ALgBA,ACHA,AGTA,ADGA,ADGA,AGTA;ALgBA,ACHA,AGTA,ADGA,ADGA,AGTA;ALgBA,ACHA,AGTA,ADGA,ADGA,AGTA,ACHA;ANmBA,ACHA,AGTA,ADGA,ADGA,AGTA,ACHA;ANmBA,ACHA,AGTA,ADGA,ADGA,AGTA,ACHA;ANmBA,ACHA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA;APsBA,ACHA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA;APsBA,ACHA,AENA,ADGA,AGTA,ACHA,ACHA;APsBA,ACHA,AENA,ADGA,AGTA,ACHA,AENA,ADGA;APsBA,ACHA,AENA,ADGA,AGTA,ACHA,AENA,ADGA;APsBA,ACHA,AENA,ADGA,AGTA,ACHA,AENA,ADGA;APsBA,ACHA,AENA,AENA,ACHA,AENA,ADGA,AENA;AT4BA,ACHA,AENA,AENA,ACHA,AENA,ADGA,AENA;AT4BA,ACHA,AIZA,ACHA,AENA,ADGA,AENA;AT4BA,ACHA,AIZA,ACHA,AENA,ADGA,AGTA,ADGA;AT4BA,ACHA,AIZA,ACHA,AENA,ADGA,AGTA,ADGA;AT4BA,ACHA,AIZA,ACHA,AENA,ADGA,AGTA,ADGA;AT4BA,ACHA,AIZA,ACHA,AENA,ADGA,AGTA,ACHA,AFMA;AT4BA,ACHA,AIZA,ACHA,AENA,ADGA,AGTA,ACHA,AFMA;AT4BA,ACHA,AIZA,ACHA,AENA,ADGA,AGTA,ACHA,AFMA;AT4BA,ACHA,AWjCA,ANkBA,AENA,ADGA,AGTA,ACHA,AFMA;AT4BA,ACHA,AWjCA,ANkBA,AENA,ADGA,AGTA,ACHA,AFMA;AT4BA,ACHA,AWjCA,ANkBA,AENA,ADGA,AGTA,ACHA,AFMA;AT4BA,ACHA,AWjCA,ANkBA,AOrBA,ALeA,ADGA,AGTA,ACHA,AFMA;AT4BA,ACHA,AWjCA,ANkBA,AOrBA,ALeA,ADGA,AGTA,ACHA,AFMA;AT4BA,ACHA,AWjCA,ACHA,ALeA,ADGA,AGTA,ACHA,AFMA;AT4BA,ACHA,AWjCA,AENA,ADGA,ALeA,AENA,ACHA,AFMA;AT4BA,ACHA,AWjCA,AENA,ADGA,ALeA,AENA,ACHA,AFMA;AT4BA,ACHA,AWjCA,AENA,ADGA,ALeA,AENA,ACHA,AFMA;AT4BA,ACHA,Ac1CA,AHSA,AENA,ADGA,ALeA,AENA,ACHA,AFMA;AT4BA,ACHA,Ac1CA,AHSA,AENA,ADGA,ALeA,AENA,ACHA,AFMA;AT4BA,ACHA,Ac1CA,AHSA,AENA,ADGA,ALeA,AENA,ACHA,AFMA;AT4BA,ACHA,Ac1CA,ACHA,AJYA,AENA,ADGA,ALeA,AENA,ACHA,AFMA;AT4BA,ACHA,Ac1CA,ACHA,AJYA,AENA,ADGA,ALeA,AENA,ACHA,AFMA;AT4BA,ACHA,Ac1CA,ACHA,AJYA,AENA,ADGA,ALeA,AENA,ACHA,AFMA;AT4BA,ACHA,Ac1CA,ACHA,ACHA,ALeA,AENA,ADGA,ALeA,AENA,ACHA,AFMA;ARyBA,Ac1CA,ACHA,ACHA,ALeA,AENA,ADGA,ALeA,AENA,ACHA,AFMA;ARyBA,Ac1CA,ACHA,ACHA,ALeA,AENA,ADGA,ALeA,AENA,ACHA,AFMA;ARyBA,Ac1CA,ACHA,ACHA,ACHA,ANkBA,AENA,ADGA,ALeA,AENA,ACHA,AFMA;ARyBA,Ac1CA,ACHA,ACHA,ACHA,ANkBA,AENA,ADGA,ALeA,AENA,ACHA,AFMA;ARyBA,Ac1CA,ACHA,ACHA,ACHA,ANkBA,ACHA,ALeA,AENA,ACHA,AFMA;ARyBA,Ac1CA,ACHA,ACHA,ACHA,ACHA,APqBA,ACHA,ALeA,AENA,ACHA,AFMA;AMjBA,ACHA,ACHA,ACHA,ACHA,APqBA,ACHA,ALeA,AENA,ACHA,AFMA;AMjBA,ACHA,ACHA,ACHA,ACHA,APqBA,ACHA,ALeA,AENA,ACHA,AFMA;AMjBA,ACHA,ACHA,ACHA,ACHA,ACHA,ARwBA,ACHA,ALeA,AENA,ACHA,AFMA;AMjBA,ACHA,ACHA,ACHA,ACHA,ACHA,ARwBA,ACHA,ALeA,AENA,ACHA,AFMA;AMjBA,ACHA,ACHA,ACHA,ACHA,ACHA,ARwBA,ACHA,ALeA,AENA,ACHA,AFMA;AMjBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AT2BA,ACHA,ALeA,AENA,ACHA,AFMA;AMjBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AT2BA,ACHA,ALeA,AENA,ACHA,AFMA;AMjBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AT2BA,ACHA,ALeA,AENA,ACHA,AFMA;AMjBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA,ACHA,ALeA,AENA,ACHA,AFMA;AMjBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA,ACHA,ALeA,AENA,ACHA,AFMA;AMjBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA,ACHA,ALeA,AENA,ACHA,AFMA;AMjBA,AQxBA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA,ACHA,ALeA,AENA,ACHA,AFMA;AMjBA,AQxBA,APqBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA,ACHA,ALeA,AENA,ACHA,AFMA;AMjBA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA,ACHA,ALeA,AENA,ACHA,AFMA;Ae5CA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AHSA,ACHA;AatCA,AT2BA,AQxBA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AFMA;AatCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AFMA;AatCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AFMA;AatCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AFMA;AatCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AFMA;AatCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA,AFMA;AatCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA;AWhCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA;AWhCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA;AWhCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA;AWhCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA;AWhCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA;AWhCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AbuCA,ACHA;AWhCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AZoCA;AWhCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AZoCA;AWhCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AZoCA;AWhCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AZoCA;AWhCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA,AZoCA;AWhCA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,AT2BA,AQxBA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,ADGA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,ADGA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,ADGA,ANkBA,AENA,ACHA,ACHA,ACHA,AGTA;ADIA,ADGA,ANkBA,AENA,ACHA,AENA,AGTA;ADIA,ADGA,AJYA,ACHA,AENA,AGTA;ADIA,ADGA,AJYA,ACHA,AENA,AGTA;ADIA,ADGA,AJYA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,ALeA,AGTA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./device/adapter\"), exports);\n__exportStar(require(\"./father\"), exports);\n__exportStar(require(\"./toolkit\"), exports);\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./connected_device\"), exports);\n__exportStar(require(\"./types\"), exports);\n","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FakeConnectedDevice = void 0;\n/**\n * Connectec device\n */\nconst types_1 = require(\"./types\");\nconst father_1 = require(\"../../father\");\n/**\n * Fake connected device\n */\nclass FakeConnectedDevice {\n    origin() {\n        return \"FAKE-DEVICE\";\n    }\n    connectionState() {\n        return types_1.ConnectionState.CONNECTED;\n    }\n    deviceName() {\n        return \"FAKE-DEVICE\";\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n        });\n    }\n    canRead() {\n        return true;\n    }\n    read(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return father_1.PsdkConst.EMPTY_BYTES;\n        });\n    }\n    write(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log('WRITE: ', data);\n        });\n    }\n    flush() {\n    }\n}\nexports.FakeConnectedDevice = FakeConnectedDevice;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadOptions = exports.WroteReporter = exports.ConnectionState = void 0;\n/**\n * Connection state\n */\nvar ConnectionState;\n(function (ConnectionState) {\n    /**\n     * connected\n     */\n    ConnectionState[\"CONNECTED\"] = \"CONNECTED\";\n    /**\n     * disconnect\n     */\n    ConnectionState[\"DISCONNECTED\"] = \"DISCONNECTED\";\n})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));\n/**\n * Wrote reporter\n */\nclass WroteReporter {\n    constructor(\n    /**\n     * Wrote is ok\n     */\n    ok, \n    /**\n     * Wrote data\n     */\n    binary, \n    /**\n     * control exit\n     */\n    controlExit, \n    /**\n     * exception\n     */\n    exception) {\n        this.ok = ok;\n        this.binary = binary;\n        this.controlExit = controlExit;\n        this.exception = exception;\n    }\n}\nexports.WroteReporter = WroteReporter;\n/**\n * Read options\n */\nclass ReadOptions {\n    constructor(options) {\n        this.timeout = options === null || options === void 0 ? void 0 : options.timeout;\n    }\n}\nexports.ReadOptions = ReadOptions;\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./args\"), exports);\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./command\"), exports);\n__exportStar(require(\"./PSDK\"), exports);\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./arg\"), exports);\n__exportStar(require(\"./common/easy\"), exports);\n__exportStar(require(\"./common/raw\"), exports);\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BasicArg = void 0;\nconst types_1 = require(\"../types\");\nclass BasicArg {\n    newline() {\n        return types_1.PsdkConst.DEF_ENABLED_NEWLINE;\n    }\n}\nexports.BasicArg = BasicArg;\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./psdk_const\"), exports);\n__exportStar(require(\"./hex_output\"), exports);\n__exportStar(require(\"./write\"), exports);\n__exportStar(require(\"./lifecycle\"), exports);\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PsdkConst = void 0;\nconst toolkit_1 = require(\"../../toolkit\");\nconst CR = '\\r';\nconst LF = '\\n';\nconst CRLF = `${CR}${LF}`;\n/**\n * constants\n */\nexports.PsdkConst = {\n    DEF_CHARSET: 'gbk',\n    CR,\n    LF,\n    CRLF,\n    QUOTE: '\"',\n    DEF_NEWLINE_BINARY: toolkit_1.ByteKit.textToU8A(CRLF),\n    DEF_AUTHORS: ['fewensa <osuni@protonmail.com>'],\n    DEF_ENABLED_NEWLINE: true,\n    DEF_WRITE_CHUNK_SIZE: 512,\n    EMPTY_BYTES: new Uint8Array([]),\n};\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./byte\"), exports);\n__exportStar(require(\"./pvariable\"), exports);\n__exportStar(require(\"./pcollection\"), exports);\n__exportStar(require(\"./pimage\"), exports);\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ByteKit = void 0;\n// @ts-ignore\nconst is_js_1 = __importDefault(require(\"is_js\"));\n/**\n * Byte kit\n */\nclass ByteKit {\n    /**\n     * Text to byte\n     * @param text text\n     */\n    static textToU8A(text) {\n        if (is_js_1.default.not.truthy(text))\n            return new Uint8Array([]);\n        let bytes = [];\n        let len, c;\n        len = text.length;\n        for (let i = 0; i < len; i++) {\n            c = text.charCodeAt(i);\n            if (c >= 0x010000 && c <= 0x10FFFF) {\n                bytes.push(((c >> 18) & 0x07) | 0xF0);\n                bytes.push(((c >> 12) & 0x3F) | 0x80);\n                bytes.push(((c >> 6) & 0x3F) | 0x80);\n                bytes.push((c & 0x3F) | 0x80);\n            }\n            else if (c >= 0x000800 && c <= 0x00FFFF) {\n                bytes.push(((c >> 12) & 0x0F) | 0xE0);\n                bytes.push(((c >> 6) & 0x3F) | 0x80);\n                bytes.push((c & 0x3F) | 0x80);\n            }\n            else if (c >= 0x000080 && c <= 0x0007FF) {\n                bytes.push(((c >> 6) & 0x1F) | 0xC0);\n                bytes.push((c & 0x3F) | 0x80);\n            }\n            else {\n                bytes.push(c & 0xFF);\n            }\n        }\n        return new Uint8Array(bytes);\n    }\n}\nexports.ByteKit = ByteKit;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PVariableKit = void 0;\nconst is_js_1 = __importDefault(require(\"is_js\"));\nclass PVariableKit {\n    /**\n     * Replace variable\n     * @param text text\n     * @param variable variable\n     */\n    static replace(text, variable) {\n        var _a;\n        if (is_js_1.default.not.truthy(text))\n            return text;\n        if (is_js_1.default.not.truthy(variable))\n            return text;\n        if (text.indexOf('{{') < 0 && text.indexOf('}}') < 0)\n            return text;\n        const regx = /[\\\\]?\\{\\{(?<varx>.*?)}}/gm;\n        const tmpMark = '__THIS_IS_MAGIC_MARK_FOR_HACK_REGEX_MATCH__';\n        while (true) {\n            const match = regx.exec(text);\n            if (match == null)\n                break;\n            const originDefined = match[0];\n            const originVarx = originDefined.replace('{{', '')\n                .replace('}}', '');\n            const varName = originVarx.trim();\n            const varValue = (_a = variable.get(varName)) !== null && _a !== void 0 ? _a : '';\n            if (originDefined.startsWith('\\\\')) {\n                const tmpDefined = originDefined.replace('\\\\{{', tmpMark);\n                text = text.replace(originDefined, tmpDefined);\n                continue;\n            }\n            text = text.replace(originDefined, varValue);\n        }\n        text = text.replace(new RegExp(tmpMark, 'g'), '{{');\n        return text;\n    }\n}\nexports.PVariableKit = PVariableKit;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CollectionKit = void 0;\nconst is_js_1 = __importDefault(require(\"is_js\"));\n/**\n * Collection kit\n */\nclass CollectionKit {\n    /**\n     * Split array\n     *\n     * @param colls collections\n     * @param size  The size of result array\n     * @return List\n     */\n    static split(colls, size) {\n        if (is_js_1.default.empty(colls))\n            return [];\n        if (size <= 0)\n            throw new Error('The size must > 0');\n        const rets = [];\n        let items = [];\n        for (const coll of colls) {\n            items.push(coll);\n            if (size == items.length) {\n                rets.push(items);\n                items = [];\n            }\n        }\n        if (0 != items.length)\n            rets.push(items);\n        return rets;\n    }\n    /**\n     * Part array\n     *\n     * @param colls collections\n     * @param parts Part length\n     * @return List\n     */\n    static parts(colls, parts) {\n        if (is_js_1.default.empty(colls)) {\n            return [];\n        }\n        if (parts <= 0)\n            throw new Error('The parts length must > 0');\n        if (colls.length <= parts) {\n            return [colls];\n        }\n        const rets = [];\n        let items = [];\n        const pnum = Math.floor(colls.length / parts);\n        for (const coll of colls) {\n            items.push(coll);\n            if (items.length == pnum) {\n                rets.push(items);\n                if (rets.length < parts)\n                    items = [];\n            }\n        }\n        return rets;\n    }\n}\nexports.CollectionKit = CollectionKit;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageKit = void 0;\n/**\n * Image kit\n */\nclass ImageKit {\n    /**\n     * process image\n     * @param canvas canvas\n     * @param width width\n     * @param height height\n     */\n    static processImage(canvas, width, height) {\n        const ctx = canvas.getContext('2d');\n        let eWidth = Math.floor((width % 8 === 0) ? (width / 8) : (width / 8 + 1));\n        let currentHeight = 0;\n        let index = 0;\n        const area = height * eWidth;\n        const bytes = []; // the bytes length is equals `area`\n        for (let b1 = 0; b1 < area; b1++) {\n            bytes[b1] = 0;\n        }\n        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        while (currentHeight < height) {\n            // let rowData = []; // the row data length is image height\n            let eightBitIndex = 0;\n            for (let x = 0; x < width; x++) {\n                eightBitIndex++;\n                if (eightBitIndex > 8) {\n                    eightBitIndex = 1;\n                    index++;\n                }\n                const n = 1 << 8 - eightBitIndex;\n                // const pixel = ctx.getImageData(x, currentHeight, 1, 1);\n                const pixels = ImageKit.fastExtractPixel(imgData, x, currentHeight, 1, 1);\n                const pixel = pixels[0];\n                // const rgba = pixel.data;\n                const red = pixel[0];\n                const green = pixel[1];\n                const blue = pixel[2];\n                if ((red + green + blue) / 3 < 128) {\n                    bytes[index] = (bytes[index] | n);\n                }\n            }\n            index = eWidth * (currentHeight + 1);\n            currentHeight += 1;\n        }\n        return new Uint8Array(bytes);\n    }\n    static fastExtractPixel(imageData, x, y, w, h) {\n        let i, j;\n        let result = [];\n        let r, g, b, a;\n        const data = imageData.data;\n        for (j = 0; j < h; j++) {\n            let idx = (x + (y + j) * imageData.width) * 4; // get left most byte index for row at y + j\n            for (i = 0; i < w; i++) {\n                r = data[idx++];\n                g = data[idx++];\n                b = data[idx++];\n                a = data[idx++];\n                // do the processing\n                result.push([r, g, b, a]);\n            }\n        }\n        return result;\n    }\n}\nexports.ImageKit = ImageKit;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HexOutput = void 0;\nconst DEF_MAX_LENGTH_OF_LINE = 32;\n/**\n * hex output\n */\nclass HexOutput {\n    // private format: boolean;\n    //\n    // private spacing: boolean;\n    //\n    // private maxLengthOfLine: number = DEF_MAX_LENGTH_OF_LINE;\n    constructor(\n    /**\n     * Is format\n     */\n    enableFormat, \n    /**\n     * Enable spacing between byte\n     */\n    spacing, \n    /**\n     * Max length of line\n     */\n    maxLengthOfLine = DEF_MAX_LENGTH_OF_LINE) {\n        this.enableFormat = enableFormat;\n        this.spacing = spacing;\n        this.maxLengthOfLine = maxLengthOfLine;\n    }\n    static def() {\n        return new HexOutput(false, false, DEF_MAX_LENGTH_OF_LINE);\n    }\n    static simple(format = true) {\n        return new HexOutput(format, true, DEF_MAX_LENGTH_OF_LINE);\n    }\n    static formatWithMaxLength(maxLengthOfLine) {\n        return new HexOutput(true, true, maxLengthOfLine);\n    }\n    /**\n     * Format binary\n     */\n    format(binary) {\n        // const hex = toHex(binary);\n        const hex = Array.from(binary, function (byte) {\n            return ('0' + (byte & 0xFF).toString(16)).slice(-2);\n        }).join('');\n        if (!this.enableFormat) {\n            return hex;\n        }\n        let fmted = '';\n        const textLength = hex.length;\n        let lineIndex = 0;\n        for (let ix = 0; ix < textLength; ix++) {\n            const seq = ix + 1;\n            const v = hex[ix];\n            fmted += v;\n            if (seq % 2 == 0 && this.spacing) {\n                if (seq < textLength) {\n                    if (lineIndex + 1 < this.maxLengthOfLine) {\n                        fmted += ' ';\n                    }\n                    lineIndex += 1;\n                }\n            }\n            if (lineIndex >= this.maxLengthOfLine) {\n                fmted += '\\n';\n                lineIndex = 0;\n            }\n        }\n        return fmted;\n    }\n}\nexports.HexOutput = HexOutput;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WriteControl = exports.DataWrote = exports.DataWrite = exports.IDataWriteCallback = exports.WriteOptions = void 0;\nconst psdk_const_1 = require(\"./psdk_const\");\n/**\n * Write to device options\n */\nclass WriteOptions {\n    constructor(\n    /**\n     * Enable data splitting\n     */\n    enableChunkWrite = true, \n    /**\n     * Part size\n     */\n    chunkSize = psdk_const_1.PsdkConst.DEF_WRITE_CHUNK_SIZE, \n    /**\n     * Data write callback\n     */\n    callback) {\n        this.enableChunkWrite = enableChunkWrite;\n        this.chunkSize = chunkSize;\n        this.callback = callback;\n    }\n    static def() {\n        return new WriteOptions(true, psdk_const_1.PsdkConst.DEF_WRITE_CHUNK_SIZE, undefined);\n    }\n}\nexports.WriteOptions = WriteOptions;\n/**\n * Data write callback\n */\nclass IDataWriteCallback {\n    failed(data, exception) {\n        console.error(`Write data failed: ${exception.message}`);\n    }\n}\nexports.IDataWriteCallback = IDataWriteCallback;\n/**\n * Data write\n */\nclass DataWrite {\n    constructor(\n    /**\n     * Wrote binary\n     */\n    binary, \n    /**\n     * Write current times\n     */\n    currentTimes, \n    /**\n     * Write total times\n     */\n    totalTimes) {\n        this.binary = binary;\n        this.currentTimes = currentTimes;\n        this.totalTimes = totalTimes;\n    }\n}\nexports.DataWrite = DataWrite;\n/**\n * Data wrote\n */\nclass DataWrote extends DataWrite {\n}\nexports.DataWrote = DataWrote;\n/**\n * Write control\n */\nvar WriteControl;\n(function (WriteControl) {\n    WriteControl[\"CONTINUE\"] = \"CONTINUE\";\n    WriteControl[\"STOP\"] = \"STOP\";\n})(WriteControl = exports.WriteControl || (exports.WriteControl = {}));\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Lifecycle = void 0;\nclass Lifecycle {\n    constructor(\n    /**\n     * Connected device\n     */\n    connectedDevice) {\n        this.connectedDevice = connectedDevice;\n    }\n}\nexports.Lifecycle = Lifecycle;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OnlyTextHeaderArg = exports.OnlyBinaryHeaderArg = exports.EasyArg = void 0;\nconst arg_1 = require(\"../arg\");\nconst command_1 = require(\"../../command\");\n/**\n * Easy argument abstract class\n */\nclass EasyArg extends arg_1.BasicArg {\n    constructor() {\n        super();\n        this.prependClauses = [];\n        this.appendClauses = [];\n    }\n    /**\n     * Append another argument for this clause\n     * @param arg\n     */\n    append(arg) {\n        this.appendClauses.push(...arg.clauses());\n        return this;\n    }\n    /**\n     * Prepend another argument for this clause\n     * @param arg\n     */\n    prepend(arg) {\n        this.prependClauses.push(...arg.clauses());\n        return this;\n    }\n    /**\n     * Get current command clauses\n     */\n    clauses() {\n        const clause = this.clause();\n        const currentClauses = [];\n        if (clause.type !== command_1.ClauseType.NONE) {\n            currentClauses.push(clause);\n            if (this.newline()) {\n                currentClauses.push(command_1.CommandClause.newline());\n            }\n        }\n        return [\n            ...this.prependClauses,\n            ...currentClauses,\n            ...this.appendClauses,\n        ];\n    }\n    clear() {\n        this.prependClauses.splice(0, this.prependClauses.length);\n        this.appendClauses.splice(0, this.appendClauses.length);\n    }\n}\nexports.EasyArg = EasyArg;\nclass OnlyBinaryHeaderArg extends EasyArg {\n    append(arg) {\n        super.append(arg);\n        return this;\n    }\n    prepend(arg) {\n        super.prepend(arg);\n        return this;\n    }\n    clause() {\n        return command_1.CommandClause.binary(this.header());\n    }\n}\nexports.OnlyBinaryHeaderArg = OnlyBinaryHeaderArg;\nclass OnlyTextHeaderArg extends EasyArg {\n    append(arg) {\n        super.append(arg);\n        return this;\n    }\n    prepend(arg) {\n        super.prepend(arg);\n        return this;\n    }\n    clause() {\n        return command_1.CommandClause.text(this.header());\n    }\n}\nexports.OnlyTextHeaderArg = OnlyTextHeaderArg;\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./print/command\"), exports);\n__exportStar(require(\"./print/commander\"), exports);\n__exportStar(require(\"./print/command_clause\"), exports);\n__exportStar(require(\"./single/appendat\"), exports);\n__exportStar(require(\"./single/binary_command\"), exports);\n__exportStar(require(\"./single/single_command\"), exports);\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultCommand = exports.BasicCommand = void 0;\n/**\n * All printer sdk command interface\n */\nconst types_1 = require(\"../../types\");\nconst js_base64_1 = require(\"js-base64\");\nconst command_clause_1 = require(\"./command_clause\");\nconst toolkit_1 = require(\"../../../toolkit\");\nconst iconv = __importStar(require(\"iconv-lite\"));\nclass BasicCommand {\n    base64() {\n        return js_base64_1.Base64.fromUint8Array(this.binary());\n    }\n}\nexports.BasicCommand = BasicCommand;\nclass DefaultCommand extends BasicCommand {\n    constructor(clauses, variable) {\n        var _a, _b;\n        super();\n        let bytes = [];\n        for (const clause of clauses) {\n            switch (clause.type) {\n                case command_clause_1.ClauseType.TEXT:\n                    const t = toolkit_1.PVariableKit.replace(clause.text, variable);\n                    //# use gbk encoding\n                    const t_buffer = iconv.encode(t, (_a = clause.charset) !== null && _a !== void 0 ? _a : types_1.PsdkConst.DEF_CHARSET);\n                    const t_binary = Array.prototype.slice.call(t_buffer, 0);\n                    bytes.push(...t_binary);\n                    //# use utf8 encoding\n                    // const t_binary = ByteKit.textToU8A(t)\n                    // const array = Array.from(t_binary)\n                    // bytes.push(...array);\n                    break;\n                case command_clause_1.ClauseType.NEWLINE:\n                case command_clause_1.ClauseType.BINARY:\n                    const b = Array.from((_b = clause.binary) !== null && _b !== void 0 ? _b : types_1.PsdkConst.EMPTY_BYTES);\n                    bytes.push(...b);\n                    break;\n            }\n        }\n        this.bytes = new Uint8Array(bytes);\n    }\n    binary() {\n        return this.bytes;\n    }\n    hex(output) {\n        return (output !== null && output !== void 0 ? output : types_1.HexOutput.def()).format(this.binary());\n    }\n    string(charset) {\n        const buffer = Array.from(this.binary());\n        // @ts-ignore\n        return iconv.decode(buffer, charset !== null && charset !== void 0 ? charset : types_1.PsdkConst.DEF_CHARSET);\n    }\n}\nexports.DefaultCommand = DefaultCommand;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommandClause = exports.ClauseType = void 0;\nconst types_1 = require(\"../../types\");\nvar ClauseType;\n(function (ClauseType) {\n    ClauseType[\"TEXT\"] = \"TEXT\";\n    ClauseType[\"BINARY\"] = \"BINARY\";\n    ClauseType[\"NEWLINE\"] = \"NEWLINE\";\n    ClauseType[\"NONE\"] = \"NONE\";\n})(ClauseType = exports.ClauseType || (exports.ClauseType = {}));\nclass CommandClause {\n    constructor(type, text, charset, binary) {\n        this._type = type;\n        this._text = text;\n        this._charset = charset;\n        this._binary = binary;\n    }\n    static text(command, charset = types_1.PsdkConst.DEF_CHARSET) {\n        return new CommandClause(ClauseType.TEXT, command, charset, undefined);\n    }\n    static binary(binary) {\n        return new CommandClause(ClauseType.BINARY, undefined, undefined, binary);\n    }\n    static newline() {\n        return new CommandClause(ClauseType.NEWLINE, undefined, undefined, types_1.PsdkConst.DEF_NEWLINE_BINARY);\n    }\n    static none() {\n        return new CommandClause(ClauseType.NONE, undefined, undefined, undefined);\n    }\n    get type() {\n        return this._type;\n    }\n    get text() {\n        return this._text;\n    }\n    get charset() {\n        return this._charset;\n    }\n    get binary() {\n        return this._binary;\n    }\n}\nexports.CommandClause = CommandClause;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Commander = void 0;\nconst command_clause_1 = require(\"./command_clause\");\nconst types_1 = require(\"../../types\");\nconst command_1 = require(\"./command\");\n/**\n * Command builder\n */\nclass Commander {\n    constructor() {\n        this.clauses = [];\n        this._variable = new Map();\n    }\n    /**\n     * Make a commander\n     */\n    static make() {\n        return new Commander();\n    }\n    /**\n     * Push a text command\n     * @param command command\n     * @param options Options: { newline: newline, charset: charset }\n     */\n    pushText(command, options) {\n        var _a, _b;\n        if (command.startsWith(types_1.PsdkConst.CRLF)) {\n            command = command.substring(2);\n        }\n        const clause = command_clause_1.CommandClause.text(command, (_a = options === null || options === void 0 ? void 0 : options.charset) !== null && _a !== void 0 ? _a : types_1.PsdkConst.DEF_CHARSET);\n        return this.pushClause(clause, (_b = options === null || options === void 0 ? void 0 : options.newline) !== null && _b !== void 0 ? _b : types_1.PsdkConst.DEF_ENABLED_NEWLINE);\n    }\n    /**\n     * Push binary command\n     * @param command Command\n     * @param newline Add new line for this command\n     */\n    pushBinary(command, newline) {\n        const clause = command_clause_1.CommandClause.binary(command);\n        return this.pushClause(clause, newline !== null && newline !== void 0 ? newline : types_1.PsdkConst.DEF_ENABLED_NEWLINE);\n    }\n    /**\n     * Push clause\n     * @param clause Command clause object\n     * @param newline Add new line for this command\n     */\n    pushClause(clause, newline) {\n        this.clauses.push(clause);\n        if (newline !== null && newline !== void 0 ? newline : types_1.PsdkConst.DEF_ENABLED_NEWLINE) {\n            this.clauses.push(command_clause_1.CommandClause.newline());\n        }\n        return this;\n    }\n    /**\n     * Push multiple clause\n     * @param clauses\n     */\n    pushClauses(clauses) {\n        clauses.forEach(item => this.pushClause(item, false));\n        return this;\n    }\n    /**\n     * Push arg\n     * @param arg arg\n     */\n    pushArg(arg) {\n        this.pushClauses(arg.clauses());\n        return this;\n    }\n    /**\n     * Add newline\n     */\n    newline() {\n        const clause = command_clause_1.CommandClause.newline();\n        return this.pushClause(clause, false);\n    }\n    /**\n     * Add a new variable\n     * @param name name\n     * @param value value\n     */\n    variable(name, value) {\n        this._variable.set(name, value);\n        return this;\n    }\n    /**\n     * Clear all commands\n     */\n    clear() {\n        this.clauses.splice(0, this.clauses.length);\n        this._variable.clear();\n        return this;\n    }\n    /**\n     * Get command\n     */\n    command() {\n        return new command_1.DefaultCommand(this.clauses, this._variable);\n    }\n}\nexports.Commander = Commander;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextAppendat = exports.Appendat = void 0;\nconst is_js_1 = __importDefault(require(\"is_js\"));\nclass Appendat {\n    constructor(argument, condition, callback) {\n        this._argument = argument;\n        this._condition = condition;\n        this._callback = callback;\n    }\n    get condition() {\n        return this._condition;\n    }\n    callback(callback) {\n        this._callback = callback;\n        return this;\n    }\n    quote() {\n        return this;\n    }\n    argument() {\n        if (is_js_1.default.not.truthy(this._callback))\n            return this._argument;\n        if (is_js_1.default.not.truthy(this._argument))\n            return undefined;\n        return this._callback.callback(this._argument);\n    }\n}\nexports.Appendat = Appendat;\nclass TextAppendat extends Appendat {\n    constructor(argument, condition, callback) {\n        super(argument, condition !== null && condition !== void 0 ? condition : true, callback);\n        this._quote = false;\n    }\n    /**\n     * Create new text appendat\n     * @param argument argument\n     * @param options options: { condition: condition for this arg, callback: value callback }\n     */\n    static create(argument, options) {\n        var _a;\n        return new TextAppendat(argument, (_a = options === null || options === void 0 ? void 0 : options.condition) !== null && _a !== void 0 ? _a : true, new class {\n            callback(data) {\n                const cb = options === null || options === void 0 ? void 0 : options.callback;\n                if (cb) {\n                    return cb(data);\n                }\n                return data;\n            }\n        });\n    }\n    callback(callback) {\n        super.callback(callback);\n        return this;\n    }\n    quote() {\n        this._quote = true;\n        return this;\n    }\n    argument() {\n        const arg = super.argument();\n        if (is_js_1.default.not.truthy(arg))\n            return arg;\n        if (this._quote) {\n            return `\"${arg}\"`;\n        }\n        return arg;\n    }\n}\nexports.TextAppendat = TextAppendat;\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BinaryCommand = void 0;\n/**\n * Binary command\n */\nconst types_1 = require(\"../../types\");\nconst iconv = __importStar(require(\"iconv-lite\"));\nconst command_clause_1 = require(\"../print/command_clause\");\nclass BinaryCommand {\n    constructor(binary) {\n        this.binary = binary !== null && binary !== void 0 ? binary : [];\n    }\n    static make() {\n        return new BinaryCommand();\n    }\n    static with(u8a) {\n        const b = Array.from(u8a);\n        return new BinaryCommand(b);\n    }\n    appendNumber(num) {\n        this.binary.push(num);\n        return this;\n    }\n    appendText(text, charset) {\n        const encoding = (charset !== null && charset !== void 0 ? charset : types_1.PsdkConst.DEF_CHARSET).toLowerCase();\n        const binary = iconv.encode(text, encoding);\n        this.binary.push(...binary);\n        return this;\n    }\n    appendU8A(u8a) {\n        const b = Array.from(u8a);\n        this.binary.push(...b);\n        return this;\n    }\n    output() {\n        return new Uint8Array(this.binary);\n    }\n    clause() {\n        const output = this.output();\n        return command_clause_1.CommandClause.binary(output);\n    }\n}\nexports.BinaryCommand = BinaryCommand;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TSPLCommand = exports.CPCLCommand = exports.SingleCommand = void 0;\nconst is_js_1 = __importDefault(require(\"is_js\"));\n/**\n * Single Command\n */\nconst appendat_1 = require(\"./appendat\");\nconst command_clause_1 = require(\"../print/command_clause\");\nclass SingleCommand {\n    constructor(symbolAfterHeader, symbolBetweenArguments, charset) {\n        this._arguments = [];\n        this._symbolAfterHeader = symbolAfterHeader;\n        this._symbolBetweenArguments = symbolBetweenArguments;\n        this._charset = charset;\n    }\n    get getHeader() {\n        return this._header;\n    }\n    get symbolAfterHeader() {\n        return this._symbolAfterHeader;\n    }\n    get symbolBetweenArguments() {\n        return this._symbolBetweenArguments;\n    }\n    header(header) {\n        this._header = header;\n        return this;\n    }\n    get charset() {\n        return this._charset;\n    }\n    append(appendat) {\n        if (!appendat.condition)\n            return this;\n        const argument = appendat.argument();\n        if (is_js_1.default.not.truthy(argument))\n            return this;\n        this._arguments.push(argument);\n        return this;\n    }\n    arguments() {\n        return this._arguments;\n    }\n}\nexports.SingleCommand = SingleCommand;\nclass BasicStringSingleCommand extends SingleCommand {\n    constructor(symbolAfterHeader, symbolBetweenArguments, charset) {\n        super(symbolAfterHeader, symbolBetweenArguments, charset);\n    }\n    append(appendat) {\n        const argument = appendat.argument();\n        if (is_js_1.default.not.truthy(argument))\n            return this;\n        if (argument == '')\n            return this;\n        super.append(appendat);\n        return this;\n    }\n    appendText(text) {\n        return this.append(appendat_1.TextAppendat.create(text !== null && text !== void 0 ? text : '', {}));\n    }\n    appendNumber(num) {\n        if (isNaN(num))\n            return this;\n        return this.append(appendat_1.TextAppendat.create((num !== null && num !== void 0 ? num : '').toString(), {}));\n    }\n    output() {\n        let ret = '';\n        if (is_js_1.default.truthy(super.getHeader)) {\n            ret += super.getHeader;\n            ret += super.symbolAfterHeader;\n        }\n        const args = super.arguments();\n        const len = args.length;\n        let seq = 0;\n        for (const arg of args) {\n            seq += 1;\n            if (is_js_1.default.not.truthy(arg))\n                continue;\n            ret += arg;\n            if (seq < len) {\n                ret += super.symbolBetweenArguments;\n            }\n        }\n        return ret;\n    }\n    clause() {\n        const output = this.output();\n        if (is_js_1.default.not.truthy(output)) {\n            return command_clause_1.CommandClause.none();\n        }\n        return command_clause_1.CommandClause.text(output, super.charset);\n    }\n}\nclass CPCLCommand extends BasicStringSingleCommand {\n    constructor(header, charset) {\n        super(' ', ' ', charset);\n        super.header(header);\n    }\n    static with(header, charset) {\n        return new CPCLCommand(header, charset);\n    }\n    append(appendat) {\n        super.append(appendat);\n        return this;\n    }\n    appendText(text) {\n        super.appendText(text);\n        return this;\n    }\n    appendNumber(num) {\n        super.appendNumber(num);\n        return this;\n    }\n}\nexports.CPCLCommand = CPCLCommand;\nclass TSPLCommand extends BasicStringSingleCommand {\n    constructor(header, charset) {\n        super(' ', ',', charset);\n        super.header(header);\n    }\n    static with(header, charset) {\n        return new TSPLCommand(header, charset);\n    }\n    append(appendat) {\n        super.append(appendat);\n        return this;\n    }\n    appendText(text) {\n        super.appendText(text);\n        return this;\n    }\n    appendNumber(num) {\n        super.appendNumber(num);\n        return this;\n    }\n}\nexports.TSPLCommand = TSPLCommand;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RawMode = exports.Raw = void 0;\nconst easy_1 = require(\"./easy\");\nconst command_1 = require(\"../../command\");\nconst types_1 = require(\"../../types\");\nclass Raw extends easy_1.EasyArg {\n    constructor() {\n        super();\n        this._newline = types_1.PsdkConst.DEF_ENABLED_NEWLINE;\n    }\n    static text(text, options) {\n        var _a, _b;\n        const raw = new Raw();\n        raw._mode = RawMode.TEXT;\n        raw._text = text;\n        raw._charset = (_a = options === null || options === void 0 ? void 0 : options.charset) !== null && _a !== void 0 ? _a : types_1.PsdkConst.DEF_CHARSET;\n        raw._newline = (_b = options === null || options === void 0 ? void 0 : options.newline) !== null && _b !== void 0 ? _b : types_1.PsdkConst.DEF_ENABLED_NEWLINE;\n        return raw;\n    }\n    static binary(binary, options) {\n        var _a, _b;\n        const raw = new Raw();\n        raw._mode = RawMode.BINARY;\n        raw._binary = binary;\n        raw._charset = (_a = options === null || options === void 0 ? void 0 : options.charset) !== null && _a !== void 0 ? _a : types_1.PsdkConst.DEF_CHARSET;\n        raw._newline = (_b = options === null || options === void 0 ? void 0 : options.newline) !== null && _b !== void 0 ? _b : types_1.PsdkConst.DEF_ENABLED_NEWLINE;\n        return raw;\n    }\n    append(arg) {\n        super.append(arg);\n        return this;\n    }\n    prepend(arg) {\n        super.prepend(arg);\n        return this;\n    }\n    clause() {\n        let clause;\n        switch (this._mode) {\n            case RawMode.TEXT:\n                clause = command_1.CommandClause.text(this._text, this._charset);\n                break;\n            case RawMode.BINARY:\n                clause = command_1.CommandClause.binary(this._binary);\n                break;\n            default:\n                clause = command_1.CommandClause.none();\n                break;\n        }\n        return clause;\n    }\n    header() {\n        return types_1.PsdkConst.EMPTY_BYTES;\n    }\n    newline() {\n        return this._newline;\n    }\n}\nexports.Raw = Raw;\nvar RawMode;\n(function (RawMode) {\n    RawMode[\"BINARY\"] = \"BINARY\";\n    RawMode[\"TEXT\"] = \"TEXT\";\n})(RawMode = exports.RawMode || (exports.RawMode = {}));\n","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PSDK = void 0;\nconst types_1 = require(\"./types\");\nconst write_operation_1 = require(\"./device/write_operation\");\nclass PSDK {\n    /**\n     * sdk version\n     */\n    sversion() {\n        return '0.0.18-snapshot';\n    }\n    /**\n     * authors\n     */\n    authors() {\n        return types_1.PsdkConst.DEF_AUTHORS;\n    }\n    /**\n     * Push raw command\n     * @param raw raw\n     */\n    raw(raw) {\n        this.commander().pushArg(raw);\n        return this;\n    }\n    /**\n     * Put variable\n     * @param name name\n     * @param value value\n     */\n    variable(name, value) {\n        this.commander().variable(name, value);\n        return this;\n    }\n    /**\n     * get command\n     */\n    command() {\n        return this.commander().command();\n    }\n    /**\n     * Clear command\n     */\n    clear() {\n        this.commander().clear();\n        return this;\n    }\n    /**\n     * Write data to device\n     */\n    write(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connectedDevice = this.connectedDevice();\n            if (!connectedDevice)\n                throw Error('It\\'s seems you missing to set connectedDevice');\n            options = options !== null && options !== void 0 ? options : types_1.WriteOptions.def();\n            const command = this.command();\n            const binary = command.binary();\n            const operation = new write_operation_1.DataWriteOperation(options, binary, connectedDevice);\n            const reporter = yield operation.write();\n            this.clear();\n            return reporter;\n        });\n    }\n    /**\n     * Newline command\n     */\n    newline() {\n        this.commander().newline();\n        return this;\n    }\n    /**\n     * Push command\n     * @param command\n     */\n    push(command) {\n        this.commander().pushArg(command);\n        return this;\n    }\n}\nexports.PSDK = PSDK;\n","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataWriteOperation = void 0;\n/**\n * Data write operation\n */\nconst types_1 = require(\"../types\");\nconst adapter_1 = require(\"../../device/adapter\");\nconst toolkit_1 = require(\"../../toolkit\");\nclass DataWriteOperation {\n    constructor(\n    /**\n     * Write options\n     * @private\n     */\n    options, \n    /**\n     * Write binary\n     * @private\n     */\n    binary, \n    /**\n     * Connected device\n     * @private\n     */\n    connectedDevice) {\n        this.options = options;\n        this.binary = binary;\n        this.connectedDevice = connectedDevice;\n    }\n    write() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.options.enableChunkWrite) {\n                const reporter = yield this.writData(this.binary);\n                this.doCallback(reporter, this.binary, 1, 1);\n                return reporter;\n            }\n            const writeData = Array.from(this.binary);\n            const parts = toolkit_1.CollectionKit.split(writeData, this.options.chunkSize);\n            const totalTimes = parts.length;\n            let currentTimes = 0;\n            for (const part of parts) {\n                currentTimes += 1;\n                const partBinary = new Uint8Array(part);\n                const reporter = yield this.writData(partBinary);\n                const control = this.doCallback(reporter, partBinary, currentTimes, totalTimes);\n                if (control == types_1.WriteControl.STOP) {\n                    reporter.controlExit = true;\n                    return reporter;\n                }\n                if (!reporter.ok) {\n                    return reporter;\n                }\n            }\n            return new adapter_1.WroteReporter(true, this.binary, false);\n        });\n    }\n    doCallback(reporter, binary, currentTimes, totalTimes) {\n        const callback = this.options.callback;\n        if (!callback)\n            return types_1.WriteControl.CONTINUE;\n        const dataWrote = new types_1.DataWrote(binary, currentTimes, totalTimes);\n        if (reporter.ok) {\n            return callback.success(dataWrote);\n        }\n        callback.failed(dataWrote, reporter.exception);\n        return types_1.WriteControl.STOP;\n    }\n    writData(binary) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this.connectedDevice.write(binary);\n                return new adapter_1.WroteReporter(true, binary, false);\n            }\n            catch (e) {\n                return new adapter_1.WroteReporter(false, binary, false, e);\n            }\n        });\n    }\n}\nexports.DataWriteOperation = DataWriteOperation;\n"]}
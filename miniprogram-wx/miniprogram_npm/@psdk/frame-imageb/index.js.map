{"version":3,"sources":["index.js","process/index.js","process/process.js","process/impls/gray.js","types.js","tools.js","process/impls/reverse.js","process/impls/threshold.js","process/basic/threshold.js","process/pbit/pbita.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA,AENA;AJaA,AGTA,AFMA,AGTA;AJaA,AGTA,AFMA,AGTA;AJaA,AGTA,AFMA,AIZA,ADGA;AJaA,AGTA,AFMA,AIZA,ADGA;AJaA,AGTA,AFMA,AIZA,ADGA;ADIA,AGTA,ALeA,AIZA,ADGA;ADIA,AGTA,ALeA,AIZA,ADGA;ADIA,AGTA,ALeA,AIZA,ADGA;ADIA,AGTA,ACHA,ANkBA,AIZA,ADGA;ADIA,AGTA,ACHA,ANkBA,AIZA,ADGA;ADIA,AGTA,ACHA,ANkBA,AIZA,ADGA;AIXA,ALeA,AGTA,ACHA,ANkBA,AIZA,ADGA;AIXA,ALeA,AGTA,ACHA,ANkBA,AIZA,ADGA;AIXA,ALeA,AGTA,ACHA,AFMA,ADGA;AIXA,ALeA,AGTA,ACHA,AENA,AJYA,ADGA;AIXA,ALeA,AGTA,ACHA,AENA,AJYA,ADGA;AIXA,ALeA,AGTA,ACHA,AENA,AJYA,ADGA;AIXA,ALeA,AGTA,ACHA,AENA,AJYA,ADGA;AIXA,ALeA,AGTA,ACHA,AENA,AJYA,ADGA;AIXA,ALeA,AGTA,AGTA,AJYA,ADGA;AIXA,AFMA,AGTA,AJYA,ADGA;AIXA,AFMA,AGTA,AJYA,ADGA;AIXA,AFMA,AGTA,AJYA,ADGA;AIXA,AFMA,AGTA,AJYA,ADGA;AIXA,AFMA,AGTA,AJYA,ADGA;AIXA,AFMA,AGTA,AJYA,ADGA;AIXA,AFMA,AGTA,AJYA,ADGA;AIXA,AFMA,AGTA,AJYA,ADGA;AIXA,AFMA,AGTA,AJYA,ADGA;AIXA,ACHA,AJYA,ADGA;AIXA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./process\"), exports);\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./process\"), exports);\n__exportStar(require(\"./impls/gray\"), exports);\n__exportStar(require(\"./impls/reverse\"), exports);\n__exportStar(require(\"./impls/threshold\"), exports);\n__exportStar(require(\"./pbit/pbita\"), exports);\n__exportStar(require(\"./basic/threshold\"), exports);\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImagebProcesser = void 0;\nclass ImagebProcesser {\n}\nexports.ImagebProcesser = ImagebProcesser;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GrayscaleImage = void 0;\nconst process_1 = require(\"../process\");\nconst types_1 = require(\"../../types\");\nconst tools_1 = require(\"../../tools\");\nclass GrayscaleImage extends process_1.ImagebProcesser {\n    constructor(options) {\n        super();\n        this._processer = options === null || options === void 0 ? void 0 : options._processer;\n    }\n    process(input) {\n        let result = tools_1.ImagebTool.convertGreyImg(input);\n        if (this._processer == null) {\n            return new types_1.ProcessedResult({\n                origin: input,\n                result: new types_1.ProcessedImage({ data: result, width: result.width, height: result.height })\n            });\n        }\n        return this._processer.process(result);\n    }\n}\nexports.GrayscaleImage = GrayscaleImage;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThresholdValueMode = exports.ProcessedImage = exports.ProcessedResult = void 0;\nclass ProcessedResult {\n    constructor(options) {\n        this.origin = options.origin;\n        this.result = options.result;\n        this.message = options.message;\n    }\n}\nexports.ProcessedResult = ProcessedResult;\nclass ProcessedImage {\n    constructor(options) {\n        this.data = options.data;\n        this.width = options.width;\n        this.height = options.height;\n        this.bytes = options.bytes;\n    }\n}\nexports.ProcessedImage = ProcessedImage;\nvar ThresholdValueMode;\n(function (ThresholdValueMode) {\n    ThresholdValueMode[ThresholdValueMode[\"sum\"] = 0] = \"sum\";\n    ThresholdValueMode[ThresholdValueMode[\"avg\"] = 1] = \"avg\";\n    ThresholdValueMode[ThresholdValueMode[\"red\"] = 2] = \"red\";\n    ThresholdValueMode[ThresholdValueMode[\"green\"] = 3] = \"green\";\n    ThresholdValueMode[ThresholdValueMode[\"blue\"] = 4] = \"blue\";\n    ThresholdValueMode[ThresholdValueMode[\"max\"] = 5] = \"max\";\n    ThresholdValueMode[ThresholdValueMode[\"min\"] = 6] = \"min\";\n})(ThresholdValueMode = exports.ThresholdValueMode || (exports.ThresholdValueMode = {}));\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImagebTool = void 0;\nclass ImagebTool {\n    static invertBitmap(canvas) {\n        const ctx = canvas.getContext('2d');\n        const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const pixeldata = pixels.data;\n        for (let i = 0, len = pixeldata.length; i < len; i += 4) {\n            pixels.data[i] = 255 - pixels.data[i];\n            pixels.data[i + 1] = 255 - pixels.data[i + 1];\n            pixels.data[i + 2] = 255 - pixels.data[i + 2];\n        }\n        ctx.putImageData(pixels, 0, 0);\n        return canvas;\n    }\n    static convertGreyImg(canvas) {\n        const ctx = canvas.getContext('2d');\n        const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const pixeldata = pixels.data;\n        for (let i = 0, len = pixeldata.length; i < len; i += 4) {\n            const gray = pixels.data[i] * 0.3 + pixels.data[i + 1] * 0.59 + pixels.data[i + 2] * 0.11;\n            pixels.data[i] = gray;\n            pixels.data[i + 1] = gray;\n            pixels.data[i + 2] = gray;\n        }\n        ctx.putImageData(pixels, 0, 0);\n        return canvas;\n    }\n    static zeroAndOne(canvas) {\n        const ctx = canvas.getContext('2d');\n        const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const index = 255 / 2; //阈值\n        for (let i = 0; i < pixels.data.length; i += 4) {\n            const R = pixels.data[i]; //R(0-255)\n            const G = pixels.data[i + 1]; //G(0-255)\n            const B = pixels.data[i + 2]; //B(0-255)\n            const Alpha = pixels.data[i + 3]; //Alpha(0-255)\n            const sum = (R + G + B) / 3;\n            if (sum > index) {\n                pixels.data[i] = 255;\n                pixels.data[i + 1] = 255;\n                pixels.data[i + 2] = 255;\n                pixels.data[i + 3] = Alpha;\n            }\n            else {\n                pixels.data[i] = 0;\n                pixels.data[i + 1] = 0;\n                pixels.data[i + 2] = 0;\n                pixels.data[i + 3] = Alpha;\n            }\n        }\n        ctx.putImageData(pixels, 0, 0);\n        return canvas;\n    }\n}\nexports.ImagebTool = ImagebTool;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReverseColorImage = void 0;\nconst process_1 = require(\"../process\");\nconst types_1 = require(\"../../types\");\nconst tools_1 = require(\"../../tools\");\nclass ReverseColorImage extends process_1.ImagebProcesser {\n    constructor(options) {\n        super();\n        this._processer = options === null || options === void 0 ? void 0 : options._processer;\n    }\n    process(input) {\n        let result = tools_1.ImagebTool.invertBitmap(input);\n        if (this._processer == null) {\n            return new types_1.ProcessedResult({\n                origin: input,\n                result: new types_1.ProcessedImage({ data: result, width: result.width, height: result.height })\n            });\n        }\n        return this._processer.process(result);\n    }\n}\nexports.ReverseColorImage = ReverseColorImage;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThresholdImage = void 0;\nconst threshold_1 = require(\"../basic/threshold\");\nclass ThresholdImage extends threshold_1.AbstractThreshold {\n    constructor(options) {\n        super(new threshold_1.PinedThresholdValue(options === null || options === void 0 ? void 0 : options.threshold));\n    }\n}\nexports.ThresholdImage = ThresholdImage;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PinedThresholdValue = exports.ThresholdValue = exports.AbstractThreshold = void 0;\nconst process_1 = require(\"../process\");\nconst types_1 = require(\"../../types\");\nconst tools_1 = require(\"../../tools\");\nclass AbstractThreshold extends process_1.ImagebProcesser {\n    constructor(threshold) {\n        super();\n        this.mode = types_1.ThresholdValueMode.avg;\n        this.threshold = threshold !== null && threshold !== void 0 ? threshold : new PinedThresholdValue();\n    }\n    process(input) {\n        let result = tools_1.ImagebTool.zeroAndOne(input);\n        return new types_1.ProcessedResult({\n            origin: input,\n            result: new types_1.ProcessedImage({ data: result, width: result.width, height: result.height })\n        });\n    }\n}\nexports.AbstractThreshold = AbstractThreshold;\nclass ThresholdValue {\n}\nexports.ThresholdValue = ThresholdValue;\nclass PinedThresholdValue extends ThresholdValue {\n    constructor(value) {\n        super();\n        this._value = value !== null && value !== void 0 ? value : 190;\n    }\n    threshold() {\n        return this._value;\n    }\n}\nexports.PinedThresholdValue = PinedThresholdValue;\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Pbita = void 0;\nconst process_1 = require(\"../process\");\nconst types_1 = require(\"../../types\");\nconst pako = __importStar(require(\"pako\"));\nconst gray_1 = require(\"../impls/gray\");\nconst reverse_1 = require(\"../impls/reverse\");\nclass Pbita extends process_1.ImagebProcesser {\n    constructor(options) {\n        super();\n        this.threshold = options.threshold;\n        this.command = options.command;\n        this.compress = options.compress;\n        this.reverse = options.reverse;\n    }\n    process(input) {\n        const width = input.width;\n        const height = input.height;\n        const grayScaleImage = new gray_1.GrayscaleImage();\n        const grayResult = grayScaleImage.process(input);\n        if (grayResult.result == null) {\n            return new types_1.ProcessedResult({\n                origin: input,\n                message: 'Failed to process gray scale: ' + grayResult.message\n            });\n        }\n        let preprocessCanvas;\n        if (this.reverse) {\n            const reverseColorImage = new reverse_1.ReverseColorImage();\n            const reverseResult = reverseColorImage.process(grayResult.result.data);\n            if (reverseResult.result == null) {\n                return new types_1.ProcessedResult({\n                    origin: input,\n                    message: 'Failed to process reverse: ' + reverseResult.message\n                });\n            }\n            preprocessCanvas = reverseResult.result.data;\n        }\n        else {\n            preprocessCanvas = grayResult.result.data;\n        }\n        let outputBytes = this._topbitimg(preprocessCanvas, width, height);\n        if (outputBytes == null) {\n            return new types_1.ProcessedResult({\n                origin: input,\n                message: 'Failed to process bitimg'\n            });\n        }\n        if (this.compress) {\n            outputBytes = pako.deflate(outputBytes, { windowBits: 10 });\n        }\n        return new types_1.ProcessedResult({\n            origin: input,\n            result: new types_1.ProcessedImage({\n                data: preprocessCanvas,\n                width: width,\n                height: height,\n                bytes: outputBytes\n            })\n        });\n    }\n    _topbitimg(canvas, width, height) {\n        if (this.command == 'tspl' && !this.compress) {\n            return this._topbitimgReverse(this._topbitimgRaw(canvas, width, height));\n        }\n        else {\n            return this._topbitimgRaw(canvas, width, height);\n        }\n    }\n    _topbitimgRaw(canvas, width, height) {\n        var _a;\n        const ctx = canvas.getContext('2d');\n        let eWidth = Math.floor((width % 8 === 0) ? (width / 8) : (width / 8 + 1));\n        let currentHeight = 0;\n        let index = 0;\n        const area = height * eWidth;\n        const bytes = []; // the bytes length is equals `area`\n        for (let b1 = 0; b1 < area; b1++) {\n            bytes[b1] = 0;\n        }\n        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        while (currentHeight < height) {\n            // let rowData = []; // the row data length is image height\n            let eightBitIndex = 0;\n            for (let x = 0; x < width; x++) {\n                eightBitIndex++;\n                if (eightBitIndex > 8) {\n                    eightBitIndex = 1;\n                    index++;\n                }\n                const n = 1 << 8 - eightBitIndex;\n                // const pixel = ctx.getImageData(x, currentHeight, 1, 1);\n                const pixels = this.fastExtractPixel(imgData, x, currentHeight, 1, 1);\n                const pixel = pixels[0];\n                // const rgba = pixel.data;\n                const red = pixel[0];\n                const green = pixel[1];\n                const blue = pixel[2];\n                if ((red + green + blue) / 3 < ((_a = this.threshold) !== null && _a !== void 0 ? _a : 190)) {\n                    bytes[index] = (bytes[index] | n);\n                }\n            }\n            index = eWidth * (currentHeight + 1);\n            currentHeight += 1;\n        }\n        return new Uint8Array(bytes);\n    }\n    _topbitimgReverse(originBytes) {\n        if (originBytes == null) {\n            return null;\n        }\n        const bytes = [];\n        for (let i = 0; i < originBytes.length; i++) {\n            bytes[i] = ~originBytes[i];\n        }\n        return new Uint8Array(bytes);\n    }\n    fastExtractPixel(imageData, x, y, w, h) {\n        let i, j;\n        let result = [];\n        let r, g, b, a;\n        const data = imageData.data;\n        for (j = 0; j < h; j++) {\n            let idx = (x + (y + j) * imageData.width) * 4; // get left most byte index for row at y + j\n            for (i = 0; i < w; i++) {\n                r = data[idx++];\n                g = data[idx++];\n                b = data[idx++];\n                a = data[idx++];\n                // do the processing\n                result.push([r, g, b, a]);\n            }\n        }\n        return result;\n    }\n}\nexports.Pbita = Pbita;\n"]}
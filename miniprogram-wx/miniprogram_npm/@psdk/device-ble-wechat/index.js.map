{"version":3,"sources":["index.js","connected.js","provider.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./connected\"), exports);\n__exportStar(require(\"./provider\"), exports);\n","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WechatBleConnectedDevice = void 0;\nconst frame_father_1 = require(\"@psdk/frame-father\");\nconst await_timeout_1 = __importDefault(require(\"await-timeout\"));\nclass WechatBleConnectedDevice {\n    constructor(options) {\n        this.device = options.device;\n        this.scpair = options.scpair;\n        this._connectionState = frame_father_1.ConnectionState.CONNECTED;\n        this.dataOfRead = [];\n        this.doListen();\n    }\n    doListen() {\n        wx.onBLECharacteristicValueChange(value => {\n            this.dataOfRead.push(value);\n        });\n        wx.onBLEConnectionStateChange(value => {\n            this._connectionState = value.connected ? frame_father_1.ConnectionState.CONNECTED : frame_father_1.ConnectionState.DISCONNECTED;\n        });\n        // wx.notifyBLECharacteristicValueChange({\n        //   deviceId: this.device.deviceId,\n        //   serviceId: this.readPair.service.uuid,\n        //   characteristicId: this.readPair.characteristic.uuid,\n        //   state: true,\n        //   success: result => console.log(result),\n        //   // @ts-ignore\n        //   fail: (e) => console.error(e),\n        // });\n    }\n    realRead() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                if (this.scpair.read == null) {\n                    reject(`the connect device not support read operation: service id: [${this.scpair.service.uuid}]`);\n                    return;\n                }\n                wx.readBLECharacteristicValue({\n                    deviceId: this.device.deviceId,\n                    serviceId: this.scpair.service.uuid,\n                    characteristicId: this.scpair.read.uuid,\n                    success: result => {\n                        if (result.errMsg.indexOf('ok') == -1) {\n                            reject(result.errMsg);\n                            return;\n                        }\n                        resolve();\n                    },\n                    // @ts-ignore\n                    fail: (e) => reject(e),\n                });\n            });\n        });\n    }\n    connectionState() {\n        return this._connectionState;\n    }\n    deviceName() {\n        return this.device.localName || this.device.name || 'NONE';\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                wx.closeBLEConnection({\n                    deviceId: this.device.deviceId,\n                    success: () => {\n                        this.device = null;\n                        this.scpair = null;\n                        resolve();\n                    },\n                    // @ts-ignore\n                    fail: (e) => reject(e),\n                });\n            });\n        });\n    }\n    canRead() {\n        return this.scpair.read != null;\n    }\n    read(options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.dataOfRead.length > 0) {\n                this.dataOfRead.splice(0, this.dataOfRead.length);\n            }\n            yield this.realRead();\n            const timeout = ((_a = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a !== void 0 ? _a : 5000);\n            const startTime = +new Date();\n            while (true) {\n                const now = +new Date();\n                if (now - startTime > timeout) {\n                    return new Uint8Array([]);\n                }\n                if (this.dataOfRead.length == 0) {\n                    yield await_timeout_1.default.set(100);\n                    continue;\n                }\n                const data = this.dataOfRead.pop();\n                const value = data.value;\n                return new Uint8Array(value);\n            }\n        });\n    }\n    write(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                wx.writeBLECharacteristicValue({\n                    deviceId: this.device.deviceId,\n                    serviceId: this.scpair.service.uuid,\n                    characteristicId: this.scpair.write.uuid,\n                    // @ts-ignore\n                    value: data.buffer,\n                    success: result => {\n                        if (result.errMsg.indexOf('ok') == -1) {\n                            reject(result.errMsg);\n                            return;\n                        }\n                        resolve();\n                    },\n                    // @ts-ignore\n                    fail: (e) => reject(e)\n                });\n            });\n        });\n    }\n    flush() {\n        this.dataOfRead.splice(0, this.dataOfRead.length);\n    }\n}\nexports.WechatBleConnectedDevice = WechatBleConnectedDevice;\n","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WechatBleBluetooth = void 0;\nconst device_bluetooth_traits_1 = require(\"@psdk/device-bluetooth-traits\");\nconst frame_father_1 = require(\"@psdk/frame-father\");\nconst await_timeout_1 = __importDefault(require(\"await-timeout\"));\nconst connected_1 = require(\"./connected\");\nclass WechatBleBluetooth extends device_bluetooth_traits_1.Jluetooth {\n    constructor(options) {\n        super();\n        this.options = options;\n        this.onBluetoothDeviceFound();\n    }\n    isConnected() {\n        if (!this.connectedDevice)\n            return false;\n        return this.connectedDevice.connectionState() === frame_father_1.ConnectionState.CONNECTED;\n    }\n    bluetoothAdapterState() {\n        return new Promise((resolve, reject) => {\n            wx.getBluetoothAdapterState({\n                success: (r) => resolve(r),\n                // @ts-ignore\n                fail: (e) => reject(e)\n            });\n        });\n    }\n    connect(device, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.isConnected()) {\n                if (!((_a = options === null || options === void 0 ? void 0 : options.autoSwitchDevice) !== null && _a !== void 0 ? _a : false)) {\n                    return this.connectedDevice;\n                }\n                yield this.connectedDevice.disconnect();\n            }\n            const origin = device.origin;\n            yield this.createBLEConnection({ deviceId: origin.deviceId, timeout: options === null || options === void 0 ? void 0 : options.timeout, });\n            yield await_timeout_1.default.set(500);\n            const services = yield this.getBLEDeviceServices({ deviceId: origin.deviceId });\n            const scpair = yield this.findSCPair({\n                deviceId: origin.deviceId,\n                services,\n            });\n            if (!scpair) {\n                return Promise.reject(`Can not get write characteristic by device: ${device.name}`);\n            }\n            this.connectedDevice = new connected_1.WechatBleConnectedDevice({\n                device: origin,\n                scpair,\n            });\n            yield this.stopDiscovery();\n            return Promise.resolve(this.connectedDevice);\n        });\n    }\n    discovered(callback) {\n        this.discoveredCallback = callback;\n    }\n    startDiscovery() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.requestLocation();\n            yield this.closeBluetoothAdapter();\n            yield await_timeout_1.default.set(300);\n            yield this.openBluetoothAdapter();\n            const state = yield this.bluetoothAdapterState();\n            if (!state.available) {\n                yield await_timeout_1.default.set(500);\n            }\n            if (state.discovering) {\n                yield this.stopDiscovery();\n                yield await_timeout_1.default.set(500);\n            }\n            return new Promise((resolve, reject) => {\n                wx.startBluetoothDevicesDiscovery({\n                    // services: this.allowServices,\n                    allowDuplicatesKey: false,\n                    interval: 0,\n                    success: () => resolve(),\n                    // @ts-ignore\n                    fail: (e) => reject(e),\n                    // complete: () => resolve(),\n                });\n            });\n        });\n    }\n    stopDiscovery() {\n        return new Promise((resolve, reject) => {\n            wx.stopBluetoothDevicesDiscovery({\n                success: (result) => resolve(result),\n                // @ts-ignore\n                fail: (e) => reject(e),\n            });\n        });\n    }\n    // ### inner function\n    openBluetoothAdapter() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                wx.openBluetoothAdapter({\n                    // @ts-ignore\n                    success: (ret) => {\n                        if (ret.errMsg && ret.errMsg.indexOf('ok') == -1) {\n                            reject(ret);\n                            return;\n                        }\n                        resolve();\n                    },\n                    // @ts-ignore\n                    fail: (e) => reject(e)\n                });\n            });\n        });\n    }\n    closeBluetoothAdapter() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                wx.closeBluetoothAdapter({\n                    // @ts-ignore\n                    success: (ret) => {\n                        if (ret.errMsg && ret.errMsg.indexOf('ok') == -1) {\n                            reject(ret);\n                            return;\n                        }\n                        resolve();\n                    },\n                    // @ts-ignore\n                    fail: (e) => reject(e)\n                });\n            });\n        });\n    }\n    onBluetoothDeviceFound() {\n        wx.onBluetoothDeviceFound((result) => __awaiter(this, void 0, void 0, function* () {\n            const foundDevices = result.devices;\n            if (!foundDevices.length) {\n                return;\n            }\n            const devices = foundDevices\n                .filter(item => {\n                var _a, _b;\n                const name = item.name || item.localName;\n                if (name)\n                    return true;\n                return (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.allowNoName) !== null && _b !== void 0 ? _b : true;\n            })\n                .map(item => new device_bluetooth_traits_1.JluetoothDevice({\n                origin: item,\n                name: item.name || item.localName,\n                deviceId: item.deviceId,\n            }));\n            if (!devices.length) {\n                return;\n            }\n            if (this.discoveredCallback) {\n                yield this.discoveredCallback(devices);\n            }\n        }));\n    }\n    createBLEConnection(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                wx.createBLEConnection({\n                    deviceId: options.deviceId,\n                    timeout: options.timeout,\n                    success: () => resolve(),\n                    // @ts-ignore\n                    fail: (e) => reject(e),\n                });\n            });\n        });\n    }\n    getBLEDeviceServices(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                wx.getBLEDeviceServices({\n                    deviceId: options.deviceId,\n                    success: (result) => {\n                        if (result.errMsg.indexOf('ok') == -1) {\n                            reject(result.errMsg);\n                            return;\n                        }\n                        resolve(result.services);\n                    },\n                    // @ts-ignore\n                    fail: (e) => reject(e),\n                });\n            });\n        });\n    }\n    getBLEDeviceCharacteristics(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                wx.getBLEDeviceCharacteristics({\n                    deviceId: options.deviceId,\n                    serviceId: options.serviceId,\n                    success: (result) => {\n                        if (result.errMsg.indexOf('ok') == -1) {\n                            reject(result.errMsg);\n                            return;\n                        }\n                        resolve(result.characteristics);\n                    },\n                    // @ts-ignore\n                    fail: (e) => reject(e),\n                });\n            });\n        });\n    }\n    requestLocation() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                // wx.authorize({\n                //   scope: 'scope.userLocation',\n                //   success: () => resolve(),\n                //   // @ts-ignore\n                //   fail: (e) => reject(e),\n                // });\n                wx.getLocation({\n                    success: () => resolve(),\n                    // @ts-ignore\n                    fail: (e) => reject(e),\n                });\n            });\n        });\n    }\n    findSCPair(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        return __awaiter(this, void 0, void 0, function* () {\n            // fill data\n            const _characteristicsMap = new Map();\n            for (const service of options.services) {\n                const characteristics = yield this.getBLEDeviceCharacteristics({\n                    deviceId: options.deviceId,\n                    serviceId: service.uuid,\n                });\n                _characteristicsMap.set(service.uuid, characteristics);\n            }\n            // use special first\n            if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.allowCharacteristic) {\n                for (const service of options.services) {\n                    if (!device_bluetooth_traits_1.TBluetoothHelpers.isAllowServices(service.uuid, (_b = this.options) === null || _b === void 0 ? void 0 : _b.allowServices)) {\n                        continue;\n                    }\n                    const characteristics = _characteristicsMap.get(service.uuid);\n                    for (const characteristic of characteristics) {\n                        if (((_c = this.options) === null || _c === void 0 ? void 0 : _c.allowCharacteristic) != characteristic.uuid)\n                            continue;\n                        const properties = characteristic.properties;\n                        return {\n                            service,\n                            write: characteristic,\n                            read: properties.read ? characteristic : null,\n                        };\n                    }\n                }\n            }\n            // choose best characteristic\n            for (const service of options.services) {\n                if (!device_bluetooth_traits_1.TBluetoothHelpers.isAllowServices(service.uuid, (_d = this.options) === null || _d === void 0 ? void 0 : _d.allowServices)) {\n                    continue;\n                }\n                const characteristics = _characteristicsMap.get(service.uuid);\n                // let readCharacteristic: GetBLEDeviceCharacteristicsSuccessData;\n                // let writeCharacteristic: GetBLEDeviceCharacteristicsSuccessData;\n                const pickedCharacteristic = characteristics.find(characteristic => {\n                    const properties = characteristic.properties;\n                    // @ts-ignore\n                    return (properties.writeNoResponse || properties.write) && (properties.read);\n                });\n                if (pickedCharacteristic) {\n                    return {\n                        service,\n                        write: pickedCharacteristic,\n                        read: pickedCharacteristic,\n                    };\n                }\n            }\n            if ((_f = (_e = this.options) === null || _e === void 0 ? void 0 : _e.allowDetectDifferentCharacteristic) !== null && _f !== void 0 ? _f : false) {\n                // choose different characteristic with write and read properties\n                for (const service of options.services) {\n                    if (!device_bluetooth_traits_1.TBluetoothHelpers.isAllowServices(service.uuid, (_g = this.options) === null || _g === void 0 ? void 0 : _g.allowServices)) {\n                        continue;\n                    }\n                    const characteristics = _characteristicsMap.get(service.uuid);\n                    const writeCharacteristic = characteristics.find(characteristic => {\n                        const properties = characteristic.properties;\n                        // @ts-ignore\n                        return (properties.writeNoResponse || properties.write);\n                    });\n                    const readCharacteristic = characteristics.find(characteristic => {\n                        const properties = characteristic.properties;\n                        return (properties.read);\n                    });\n                    if (writeCharacteristic && readCharacteristic) {\n                        return {\n                            service,\n                            write: writeCharacteristic,\n                            read: readCharacteristic,\n                        };\n                    }\n                }\n            }\n            else {\n                // only write\n                for (const service of options.services) {\n                    if (!device_bluetooth_traits_1.TBluetoothHelpers.isAllowServices(service.uuid, (_h = this.options) === null || _h === void 0 ? void 0 : _h.allowServices)) {\n                        continue;\n                    }\n                    const characteristics = _characteristicsMap.get(service.uuid);\n                    const writeCharacteristic = characteristics.find(characteristic => {\n                        const properties = characteristic.properties;\n                        // @ts-ignore\n                        return (properties.writeNoResponse || properties.write);\n                    });\n                    if (writeCharacteristic) {\n                        return {\n                            service,\n                            write: writeCharacteristic,\n                        };\n                    }\n                }\n            }\n        });\n    }\n}\nexports.WechatBleBluetooth = WechatBleBluetooth;\n"]}